// Generated by CoffeeScript 1.10.0
var Err, __checkAuth, __checkParams, __endpoints, __handle, __hasObjectValue, __mergeObjects, __methods, __options, bodyParser, compression, express, pkg;

express = require("express");

compression = require("compression");

bodyParser = require("body-parser");

Err = require("./error");

pkg = require("../package");

__options = {
  port: 8080,
  dataKey: "data",
  errorKey: "error",
  log: true,
  logStack: true,
  meta: true,
  requestLimit: "1mb",
  docs: {
    enabled: true,
    route: "/docs",
    auth: false
  },
  auth: function(req, res, next) {
    if (!req.headers["x-token"]) {
      return res.send401();
    }
    return next();
  }
};

__methods = ["get", "post", "put", "delete", "head"];

__endpoints = {};

__hasObjectValue = function(o, path) {
  var i, k, len, p, t, v;
  t = {};
  for (k in o) {
    v = o[k];
    t[k] = v;
  }
  for (i = 0, len = path.length; i < len; i++) {
    p = path[i];
    if (!t[p]) {
      return false;
    }
    t = t[p];
  }
  return true;
};

__checkParams = function(params, req, res, next) {
  var i, len, p;
  if (params.length === 0) {
    return next();
  }
  for (i = 0, len = params.length; i < len; i++) {
    p = params[i];
    if (!req.body[p]) {
      if (p.indexOf(".") < 0) {
        return next(new Err("Parameter '" + p + "' is missing", "missing_parameter"));
      }
      if (!__hasObjectValue(req.body, p.split("."))) {
        return next(new Err("Parameter '" + p + "' is missing", "missing_parameter"));
      }
    }
  }
  return next();
};

__checkAuth = function(req, res, requiredAuth, authMethod, cb) {
  if (!requiredAuth) {
    return cb();
  }
  return authMethod(req, res, cb);
};

__handle = function(app, options, method, route, requiredAuth, requiredParams, docs, callback) {
  if (typeof requiredAuth === "function") {
    callback = requiredAuth;
    requiredAuth = false;
    requiredParams = [];
    docs = null;
  } else if (typeof requiredParams === "function") {
    callback = requiredParams;
    requiredParams = [];
    docs = null;
  } else if (typeof docs === "function") {
    callback = docs;
    docs = null;
  }
  __endpoints[(method.toUpperCase()) + " " + route] = {
    docs: docs,
    required_params: requiredParams,
    required_auth: requiredAuth
  };
  return app[method](route, function(req, res, next) {
    return __checkAuth(req, res, requiredAuth, options.auth, function(err) {
      if (err) {
        return next(err);
      }
      return __checkParams(requiredParams, req, res, function(err) {
        if (err) {
          return next(err);
        }
        return callback(req, res, function(err, data) {
          if (err) {
            return next(err);
          }
          return res.sendData(data);
        });
      });
    });
  });
};

__mergeObjects = function(o1, o2) {
  var k, o, v;
  o = {};
  for (k in o2) {
    v = o2[k];
    if (o1[k] === void 0) {
      o[k] = v;
      continue;
    }
    if (typeof v !== "object") {
      o[k] = o1[k];
      continue;
    }
    o[k] = __mergeObjects(o1[k], v);
  }
  return o;
};

module.exports = function(options) {
  var app, cb, i, len, method, o, squirrel;
  if (options == null) {
    options = {};
  }
  o = __mergeObjects(options, __options);
  app = express();
  app.use(function(req, res, next) {
    var d;
    app.set("json spaces", req.query.pretty === void 0 ? 0 : 4);
    d = new Date;
    res.send404 = function(message) {
      if (message == null) {
        message = "Page not found";
      }
      res.status(404);
      return next(new Err(message, "page_not_found"));
    };
    res.send401 = function(message) {
      if (message == null) {
        message = "Unauthorized request";
      }
      res.status(401);
      return next(new Err(message, "unauthorized_request"));
    };
    res.sendData = function(data, key) {
      var body, endpoint, error, r, took;
      if (key == null) {
        key = o.dataKey;
      }
      r = {};
      r[key] = data;
      body = req.body;
      if (JSON.stringify(body).length > 1024) {
        body = "Body too long";
      }
      took = Date.now() - d.getTime();
      endpoint = req.method + " " + req.path;
      if (o.meta && req.query.nometa === void 0) {
        r._meta = {
          took: took,
          endpoint: endpoint,
          body: body,
          rs: {
            version: pkg.version,
            module: "https://www.npmjs.com/package/" + pkg.name
          },
          request: {
            endpoint: endpoint,
            body: body,
            query: req.query,
            headers: req.headers
          }
        };
      }
      if (o.log) {
        error = "";
        console.log(new Date, res.statusCode + " " + req.method + " " + req.path + " BODY: " + (JSON.stringify(body)) + " QUERY: " + (JSON.stringify(req.query)) + " HEADERS: " + (JSON.stringify(req.headers)) + " TOOK: " + took + " ms");
        console.log("");
      }
      return res.json(r);
    };
    return next();
  });
  app.use(compression());
  app.use(bodyParser.json({
    limit: o.requestLimit
  }));
  squirrel = {
    use: function(route, callback) {
      if (!callback) {
        return app.use(route);
      }
      return app.use(route, callback);
    }
  };
  cb = function(method) {
    return function(route, requiredAuth, requiredParams, docs, callback) {
      return __handle(app, o, method, route, requiredAuth, requiredParams, docs, callback);
    };
  };
  for (i = 0, len = __methods.length; i < len; i++) {
    method = __methods[i];
    squirrel[method] = cb(method);
  }
  if (o.docs.enabled) {
    squirrel.get(o.docs.route, o.docs.auth, [], "Documentation of this API.", function(req, res, next) {
      return next(false, __endpoints);
    });
  }
  squirrel.listen = function() {
    app.use("*", function(req, res, next) {
      return res.send404();
    });
    app.use(function(err, req, res, next) {
      if (!(err instanceof Err)) {
        err = new Err(err);
      }
      if (o.log) {
        console.error(err.message);
        if (o.logStack) {
          console.error(err.stack);
        }
      }
      if (res.statusCode === 200) {
        res.status(500);
      }
      return res.sendData({
        message: err.message,
        code: err.code
      }, o.errorKey);
    });
    app.listen(o.port);
    if (o.log) {
      return console.log(new Date, "Listening on " + o.port);
    }
  };
  return squirrel;
};

module.exports.Error = Err;
